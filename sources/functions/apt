#!/bin/bash
# Functions for more streamlined script interfacing with apt
# Flying_sausages for Swizzin 2020
# GPLv3 Applies

if [[ -z $log ]]; then log="/root/logs/swizzin.log"; fi

# Checks arguments and exports variables to add functionality to rest of packages
_process_apt_args() {
    # idiomatic parameter and option handling in sh
    _unset_apt_args
    _apt_packages=()
    while test $# -gt 0
    do
        case "$1" in
            --interactive) export _apt_interactive=true
                echo "Info: APT set to interactive" | tee -a $log
                ;;
            --ignore-errors) export _apt_ignore_errors=true
                echo "Info: APT will ignore errors" | tee -a $log
                ;;
            --skip-checks) export _apt_skip_checks=true
                echo "Info: APT will skip sanity checks" | tee -a $log
                ;;
            --skip-update) export _apt_skip_update=true
                echo "Info: APT will skip update" | tee -a $log
                ;;
            --purge) export _apt_remove_purge=true
                echo "Info: APT will purge packages" | tee -a $log
                ;;
            -*) echo "Error: Invalid option: $1"
                exit 1
                ;;
            *) _apt_packages+=("$1")
                ;;
        esac
        shift
    done

    if [[ -z ${_apt_packages[1]} ]]; then
        export _apt_packages
    fi
}

# Overwrites all the variables we use in this script
_unset_apt_args (){
    unset _apt_ignore_errors
    unset _apt_interactive
    unset _apt_ignore_errors
    unset _apt_skip_checks
    unset _apt_remove_purge
    unset _apt_packages
}

#Prints the last apt log
_get_last_apt_log (){
    # TODO replace with actual APT log instead
    tac $log | sed '/Reading package lists.../q' | tac
}

_apt_logcheck (){
    if [[ $(_get_last_apt_log | grep 'E:') ]]; then
        echo "Error: apt failed. Please consult errors above and/or in the log." | tee -a $log
        if [[ $_apt_ignore_errors != "true" ]]; then 
            exit 1
        fi
    fi
}

#Returns the version of the candidate package to install
get_candidate_version () {
    package=$1
    apt-cache policy "${package}" | grep Candidate | awk '{print $2}' | cut -d- -f 1 | cut -d+ -f 1
}

# Checks if a package is installed using package manager
# $1 the package to check for
# Returns code 0 in case a package is installed, 1 if missing
_check_installed (){
    if dpkg -s "$1" >> $log 2>&1; then
        return 0
    else 
        return 1
    fi
}

# Check if apt is locked
_check_dpkg_lock (){
    if [[ $_apt_skip_checks != "true" ]]; then 
        # dpkg -i /dev/zero >> $log 2>&1
        if lsof /var/lib/dpkg/lock >> $log 2>&1; then
            offender=$(lsof /var/lib/dpkg/lock | grep dpkg | awk '{ print $1 }')
            echo "Error: dpkg database is locked by $offender. Please try again later" | tee -a $log
            if [[ $_apt_ignore_errors != "true" ]]; then 
                exit 1
            fi
        fi
    fi
}

# Check if install can run or not
_apt_check (){
    if [[ $_apt_skip_checks != "true" ]]; then 
        if ! apt-get check >> $log 2>&1; then
            _get_last_apt_log | grep 'E:\|W:'
            echo "Error: \`apt-get check\` failed, you may have broken packages. Aborting installation" | tee -a $log
            if [[ $_apt_ignore_errors != "true" ]]; then 
                exit 1
            fi
        fi
    fi
}

# Performs a simulation of an apt-get call
_apt_simulate(){
    if [[ $_apt_skip_checks != "true" ]]; then 
        if  ! apt-get --simulate "$@" >> $log 2>&1; then
            _get_last_apt_log | grep 'E:'
            echo "Error: The simulation check resulted in an error. Please consult the log. Aborting install" | tee -a $log
            if [[ $_apt_ignore_errors != "true" ]]; then 
                exit 1
            fi
        fi
    fi
}

# Performing apt update and checking if it succeeded
# shellcheck disable=SC2120
apt_update () {
    if [[ -n $1 ]]; then 
        _process_apt_args "$@"
    fi
    if [[ $_apt_skip_update != "true" ]]; then 
        echo "Performing apt update" | tee -a $log
        apt-get update >> $log 2>&1
        _apt_logcheck
    fi
}
export -f apt_update

# Performs an upgrade and checks if it succeeded
apt_upgrade() {
    _process_apt_args "$@"
    _check_dpkg_lock
    _apt_check
    apt_update
    _apt_simulate upgrade

    echo "Performing apt upgrade" | tee -a $log
    upgradable=$(apt list --upgradable 2>/dev/null | grep -c upgradable)
    echo "$upgradable packages to upgrade."
    if [[ $_apt_interactive == "true" ]]; then
        DEBIAN_FRONTEND=readline apt-get upgrade -y | tee -a $log 
    else
        DEBIAN_FRONTEND=noninteractive apt-get upgrade -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y >> $log 2>&1
    fi

    _apt_logcheck
}
export -f apt_upgrade

#Takes a space separated list of packages to install in a non-interactive manner
apt_install (){
    _process_apt_args "$@"
    _check_dpkg_lock
    _apt_check

    apt_update
    
    _apt_simulate install "${_apt_packages[@]}"

    # Run the install
    echo "Performing installation of ${#_apt_packages[@]} apt packages (${_apt_packages[*]})" | tee -a $log
    if [[ $_apt_interactive == "true" ]]; then
        # TODO test the behaviour of this, I haven't had the time yet
        DEBIAN_FRONTEND=readline apt-get install -y "${_apt_packages[@]}" | tee -a $log 
    else
        DEBIAN_FRONTEND=noninteractive apt-get install -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y "${_apt_packages[@]}" >> $log 2>&1
    fi

    _apt_logcheck

    echo "Apt install complete"

    # TODO check if any configs have changed and alert the users
}
export -f apt_install

apt_remove (){
    _process_apt_args "$@"
    _check_dpkg_lock
    _apt_check

    # apt_update
    
    _apt_simulate remove "${_apt_packages[@]}"

     # Run the install
    echo "Performing removal of ${#_apt_packages[@]} apt packages (${_apt_packages[*]})" | tee -a $log
    if [[ $_apt_interactive == "true" ]]; then
        # TODO test the behaviour of this, I haven't had the time yet
        DEBIAN_FRONTEND=readline apt-get remove -y "${_apt_packages[@]}" | tee -a $log 
    else
        DEBIAN_FRONTEND=noninteractive apt-get remove -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y "${_apt_packages[@]}" >> $log 2>&1
    fi

    _apt_logcheck

    echo "Apt remove complete"

    # TODO check if any configs have changed and alert the users
}

apt_autoremove (){
    _process_apt_args "$@"
    _check_dpkg_lock
    _apt_check
    _apt_simulate autoremove
    # TODO perform a check if it is necessary

    echo "Performing auto-removal of unnecessary apt dependencies" | tee -a $log
    if [[ $_apt_interactive == "true" ]]; then
        # TODO test the behaviour of this, I haven't had the time yet
        DEBIAN_FRONTEND=readline apt-get autoremove -y | tee -a $log 
    else
        DEBIAN_FRONTEND=noninteractive apt-get autoremove -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y >> $log 2>&1
    fi

    _apt_logcheck

    echo "Apt remove complete"

    # TODO check if any configs have changed and alert the users
}

